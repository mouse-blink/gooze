// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	fs "io/fs"

	adapter "github.com/mouse-blink/gooze/internal/adapter"

	mock "github.com/stretchr/testify/mock"

	model "github.com/mouse-blink/gooze/internal/model"
)

// MockSourceFSAdapter is an autogenerated mock type for the SourceFSAdapter type
type MockSourceFSAdapter struct {
	mock.Mock
}

type MockSourceFSAdapter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSourceFSAdapter) EXPECT() *MockSourceFSAdapter_Expecter {
	return &MockSourceFSAdapter_Expecter{mock: &_m.Mock}
}

// CopyDir provides a mock function with given fields: src, dst
func (_m *MockSourceFSAdapter) CopyDir(src model.Path, dst model.Path) error {
	ret := _m.Called(src, dst)

	if len(ret) == 0 {
		panic("no return value specified for CopyDir")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(model.Path, model.Path) error); ok {
		r0 = rf(src, dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSourceFSAdapter_CopyDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyDir'
type MockSourceFSAdapter_CopyDir_Call struct {
	*mock.Call
}

// CopyDir is a helper method to define mock.On call
//   - src model.Path
//   - dst model.Path
func (_e *MockSourceFSAdapter_Expecter) CopyDir(src interface{}, dst interface{}) *MockSourceFSAdapter_CopyDir_Call {
	return &MockSourceFSAdapter_CopyDir_Call{Call: _e.mock.On("CopyDir", src, dst)}
}

func (_c *MockSourceFSAdapter_CopyDir_Call) Run(run func(src model.Path, dst model.Path)) *MockSourceFSAdapter_CopyDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path), args[1].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_CopyDir_Call) Return(_a0 error) *MockSourceFSAdapter_CopyDir_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_CopyDir_Call) RunAndReturn(run func(model.Path, model.Path) error) *MockSourceFSAdapter_CopyDir_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTempDir provides a mock function with given fields: pattern
func (_m *MockSourceFSAdapter) CreateTempDir(pattern string) (model.Path, error) {
	ret := _m.Called(pattern)

	if len(ret) == 0 {
		panic("no return value specified for CreateTempDir")
	}

	var r0 model.Path
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (model.Path, error)); ok {
		return rf(pattern)
	}
	if rf, ok := ret.Get(0).(func(string) model.Path); ok {
		r0 = rf(pattern)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(pattern)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_CreateTempDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTempDir'
type MockSourceFSAdapter_CreateTempDir_Call struct {
	*mock.Call
}

// CreateTempDir is a helper method to define mock.On call
//   - pattern string
func (_e *MockSourceFSAdapter_Expecter) CreateTempDir(pattern interface{}) *MockSourceFSAdapter_CreateTempDir_Call {
	return &MockSourceFSAdapter_CreateTempDir_Call{Call: _e.mock.On("CreateTempDir", pattern)}
}

func (_c *MockSourceFSAdapter_CreateTempDir_Call) Run(run func(pattern string)) *MockSourceFSAdapter_CreateTempDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockSourceFSAdapter_CreateTempDir_Call) Return(_a0 model.Path, _a1 error) *MockSourceFSAdapter_CreateTempDir_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_CreateTempDir_Call) RunAndReturn(run func(string) (model.Path, error)) *MockSourceFSAdapter_CreateTempDir_Call {
	_c.Call.Return(run)
	return _c
}

// DetectTestFile provides a mock function with given fields: sourcePath
func (_m *MockSourceFSAdapter) DetectTestFile(sourcePath model.Path) (model.Path, error) {
	ret := _m.Called(sourcePath)

	if len(ret) == 0 {
		panic("no return value specified for DetectTestFile")
	}

	var r0 model.Path
	var r1 error
	if rf, ok := ret.Get(0).(func(model.Path) (model.Path, error)); ok {
		return rf(sourcePath)
	}
	if rf, ok := ret.Get(0).(func(model.Path) model.Path); ok {
		r0 = rf(sourcePath)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	if rf, ok := ret.Get(1).(func(model.Path) error); ok {
		r1 = rf(sourcePath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_DetectTestFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DetectTestFile'
type MockSourceFSAdapter_DetectTestFile_Call struct {
	*mock.Call
}

// DetectTestFile is a helper method to define mock.On call
//   - sourcePath model.Path
func (_e *MockSourceFSAdapter_Expecter) DetectTestFile(sourcePath interface{}) *MockSourceFSAdapter_DetectTestFile_Call {
	return &MockSourceFSAdapter_DetectTestFile_Call{Call: _e.mock.On("DetectTestFile", sourcePath)}
}

func (_c *MockSourceFSAdapter_DetectTestFile_Call) Run(run func(sourcePath model.Path)) *MockSourceFSAdapter_DetectTestFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_DetectTestFile_Call) Return(_a0 model.Path, _a1 error) *MockSourceFSAdapter_DetectTestFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_DetectTestFile_Call) RunAndReturn(run func(model.Path) (model.Path, error)) *MockSourceFSAdapter_DetectTestFile_Call {
	_c.Call.Return(run)
	return _c
}

// FileInfo provides a mock function with given fields: path
func (_m *MockSourceFSAdapter) FileInfo(path model.Path) (fs.FileInfo, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for FileInfo")
	}

	var r0 fs.FileInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(model.Path) (fs.FileInfo, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(model.Path) fs.FileInfo); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fs.FileInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(model.Path) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_FileInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FileInfo'
type MockSourceFSAdapter_FileInfo_Call struct {
	*mock.Call
}

// FileInfo is a helper method to define mock.On call
//   - path model.Path
func (_e *MockSourceFSAdapter_Expecter) FileInfo(path interface{}) *MockSourceFSAdapter_FileInfo_Call {
	return &MockSourceFSAdapter_FileInfo_Call{Call: _e.mock.On("FileInfo", path)}
}

func (_c *MockSourceFSAdapter_FileInfo_Call) Run(run func(path model.Path)) *MockSourceFSAdapter_FileInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_FileInfo_Call) Return(_a0 fs.FileInfo, _a1 error) *MockSourceFSAdapter_FileInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_FileInfo_Call) RunAndReturn(run func(model.Path) (fs.FileInfo, error)) *MockSourceFSAdapter_FileInfo_Call {
	_c.Call.Return(run)
	return _c
}

// FindProjectRoot provides a mock function with given fields: startPath
func (_m *MockSourceFSAdapter) FindProjectRoot(startPath model.Path) (model.Path, error) {
	ret := _m.Called(startPath)

	if len(ret) == 0 {
		panic("no return value specified for FindProjectRoot")
	}

	var r0 model.Path
	var r1 error
	if rf, ok := ret.Get(0).(func(model.Path) (model.Path, error)); ok {
		return rf(startPath)
	}
	if rf, ok := ret.Get(0).(func(model.Path) model.Path); ok {
		r0 = rf(startPath)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	if rf, ok := ret.Get(1).(func(model.Path) error); ok {
		r1 = rf(startPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_FindProjectRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindProjectRoot'
type MockSourceFSAdapter_FindProjectRoot_Call struct {
	*mock.Call
}

// FindProjectRoot is a helper method to define mock.On call
//   - startPath model.Path
func (_e *MockSourceFSAdapter_Expecter) FindProjectRoot(startPath interface{}) *MockSourceFSAdapter_FindProjectRoot_Call {
	return &MockSourceFSAdapter_FindProjectRoot_Call{Call: _e.mock.On("FindProjectRoot", startPath)}
}

func (_c *MockSourceFSAdapter_FindProjectRoot_Call) Run(run func(startPath model.Path)) *MockSourceFSAdapter_FindProjectRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_FindProjectRoot_Call) Return(_a0 model.Path, _a1 error) *MockSourceFSAdapter_FindProjectRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_FindProjectRoot_Call) RunAndReturn(run func(model.Path) (model.Path, error)) *MockSourceFSAdapter_FindProjectRoot_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: root
func (_m *MockSourceFSAdapter) Get(root []model.Path) ([]model.Source, error) {
	ret := _m.Called(root)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []model.Source
	var r1 error
	if rf, ok := ret.Get(0).(func([]model.Path) ([]model.Source, error)); ok {
		return rf(root)
	}
	if rf, ok := ret.Get(0).(func([]model.Path) []model.Source); ok {
		r0 = rf(root)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Source)
		}
	}

	if rf, ok := ret.Get(1).(func([]model.Path) error); ok {
		r1 = rf(root)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockSourceFSAdapter_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - root []model.Path
func (_e *MockSourceFSAdapter_Expecter) Get(root interface{}) *MockSourceFSAdapter_Get_Call {
	return &MockSourceFSAdapter_Get_Call{Call: _e.mock.On("Get", root)}
}

func (_c *MockSourceFSAdapter_Get_Call) Run(run func(root []model.Path)) *MockSourceFSAdapter_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_Get_Call) Return(_a0 []model.Source, _a1 error) *MockSourceFSAdapter_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_Get_Call) RunAndReturn(run func([]model.Path) ([]model.Source, error)) *MockSourceFSAdapter_Get_Call {
	_c.Call.Return(run)
	return _c
}

// HashFile provides a mock function with given fields: path
func (_m *MockSourceFSAdapter) HashFile(path model.Path) (string, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for HashFile")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(model.Path) (string, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(model.Path) string); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(model.Path) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_HashFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashFile'
type MockSourceFSAdapter_HashFile_Call struct {
	*mock.Call
}

// HashFile is a helper method to define mock.On call
//   - path model.Path
func (_e *MockSourceFSAdapter_Expecter) HashFile(path interface{}) *MockSourceFSAdapter_HashFile_Call {
	return &MockSourceFSAdapter_HashFile_Call{Call: _e.mock.On("HashFile", path)}
}

func (_c *MockSourceFSAdapter_HashFile_Call) Run(run func(path model.Path)) *MockSourceFSAdapter_HashFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_HashFile_Call) Return(_a0 string, _a1 error) *MockSourceFSAdapter_HashFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_HashFile_Call) RunAndReturn(run func(model.Path) (string, error)) *MockSourceFSAdapter_HashFile_Call {
	_c.Call.Return(run)
	return _c
}

// JoinPath provides a mock function with given fields: elem
func (_m *MockSourceFSAdapter) JoinPath(elem ...string) model.Path {
	_va := make([]interface{}, len(elem))
	for _i := range elem {
		_va[_i] = elem[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JoinPath")
	}

	var r0 model.Path
	if rf, ok := ret.Get(0).(func(...string) model.Path); ok {
		r0 = rf(elem...)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	return r0
}

// MockSourceFSAdapter_JoinPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JoinPath'
type MockSourceFSAdapter_JoinPath_Call struct {
	*mock.Call
}

// JoinPath is a helper method to define mock.On call
//   - elem ...string
func (_e *MockSourceFSAdapter_Expecter) JoinPath(elem ...interface{}) *MockSourceFSAdapter_JoinPath_Call {
	return &MockSourceFSAdapter_JoinPath_Call{Call: _e.mock.On("JoinPath",
		append([]interface{}{}, elem...)...)}
}

func (_c *MockSourceFSAdapter_JoinPath_Call) Run(run func(elem ...string)) *MockSourceFSAdapter_JoinPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *MockSourceFSAdapter_JoinPath_Call) Return(_a0 model.Path) *MockSourceFSAdapter_JoinPath_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_JoinPath_Call) RunAndReturn(run func(...string) model.Path) *MockSourceFSAdapter_JoinPath_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFile provides a mock function with given fields: path
func (_m *MockSourceFSAdapter) ReadFile(path model.Path) ([]byte, error) {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for ReadFile")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(model.Path) ([]byte, error)); ok {
		return rf(path)
	}
	if rf, ok := ret.Get(0).(func(model.Path) []byte); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(model.Path) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_ReadFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFile'
type MockSourceFSAdapter_ReadFile_Call struct {
	*mock.Call
}

// ReadFile is a helper method to define mock.On call
//   - path model.Path
func (_e *MockSourceFSAdapter_Expecter) ReadFile(path interface{}) *MockSourceFSAdapter_ReadFile_Call {
	return &MockSourceFSAdapter_ReadFile_Call{Call: _e.mock.On("ReadFile", path)}
}

func (_c *MockSourceFSAdapter_ReadFile_Call) Run(run func(path model.Path)) *MockSourceFSAdapter_ReadFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_ReadFile_Call) Return(_a0 []byte, _a1 error) *MockSourceFSAdapter_ReadFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_ReadFile_Call) RunAndReturn(run func(model.Path) ([]byte, error)) *MockSourceFSAdapter_ReadFile_Call {
	_c.Call.Return(run)
	return _c
}

// RelPath provides a mock function with given fields: base, target
func (_m *MockSourceFSAdapter) RelPath(base model.Path, target model.Path) (model.Path, error) {
	ret := _m.Called(base, target)

	if len(ret) == 0 {
		panic("no return value specified for RelPath")
	}

	var r0 model.Path
	var r1 error
	if rf, ok := ret.Get(0).(func(model.Path, model.Path) (model.Path, error)); ok {
		return rf(base, target)
	}
	if rf, ok := ret.Get(0).(func(model.Path, model.Path) model.Path); ok {
		r0 = rf(base, target)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	if rf, ok := ret.Get(1).(func(model.Path, model.Path) error); ok {
		r1 = rf(base, target)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_RelPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RelPath'
type MockSourceFSAdapter_RelPath_Call struct {
	*mock.Call
}

// RelPath is a helper method to define mock.On call
//   - base model.Path
//   - target model.Path
func (_e *MockSourceFSAdapter_Expecter) RelPath(base interface{}, target interface{}) *MockSourceFSAdapter_RelPath_Call {
	return &MockSourceFSAdapter_RelPath_Call{Call: _e.mock.On("RelPath", base, target)}
}

func (_c *MockSourceFSAdapter_RelPath_Call) Run(run func(base model.Path, target model.Path)) *MockSourceFSAdapter_RelPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path), args[1].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_RelPath_Call) Return(_a0 model.Path, _a1 error) *MockSourceFSAdapter_RelPath_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_RelPath_Call) RunAndReturn(run func(model.Path, model.Path) (model.Path, error)) *MockSourceFSAdapter_RelPath_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveAll provides a mock function with given fields: path
func (_m *MockSourceFSAdapter) RemoveAll(path model.Path) error {
	ret := _m.Called(path)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(model.Path) error); ok {
		r0 = rf(path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSourceFSAdapter_RemoveAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveAll'
type MockSourceFSAdapter_RemoveAll_Call struct {
	*mock.Call
}

// RemoveAll is a helper method to define mock.On call
//   - path model.Path
func (_e *MockSourceFSAdapter_Expecter) RemoveAll(path interface{}) *MockSourceFSAdapter_RemoveAll_Call {
	return &MockSourceFSAdapter_RemoveAll_Call{Call: _e.mock.On("RemoveAll", path)}
}

func (_c *MockSourceFSAdapter_RemoveAll_Call) Run(run func(path model.Path)) *MockSourceFSAdapter_RemoveAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_RemoveAll_Call) Return(_a0 error) *MockSourceFSAdapter_RemoveAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_RemoveAll_Call) RunAndReturn(run func(model.Path) error) *MockSourceFSAdapter_RemoveAll_Call {
	_c.Call.Return(run)
	return _c
}

// Walk provides a mock function with given fields: root, recursive, fn
func (_m *MockSourceFSAdapter) Walk(root model.Path, recursive bool, fn adapter.FilepathWalkFunc) error {
	ret := _m.Called(root, recursive, fn)

	if len(ret) == 0 {
		panic("no return value specified for Walk")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(model.Path, bool, adapter.FilepathWalkFunc) error); ok {
		r0 = rf(root, recursive, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSourceFSAdapter_Walk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Walk'
type MockSourceFSAdapter_Walk_Call struct {
	*mock.Call
}

// Walk is a helper method to define mock.On call
//   - root model.Path
//   - recursive bool
//   - fn adapter.FilepathWalkFunc
func (_e *MockSourceFSAdapter_Expecter) Walk(root interface{}, recursive interface{}, fn interface{}) *MockSourceFSAdapter_Walk_Call {
	return &MockSourceFSAdapter_Walk_Call{Call: _e.mock.On("Walk", root, recursive, fn)}
}

func (_c *MockSourceFSAdapter_Walk_Call) Run(run func(root model.Path, recursive bool, fn adapter.FilepathWalkFunc)) *MockSourceFSAdapter_Walk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path), args[1].(bool), args[2].(adapter.FilepathWalkFunc))
	})
	return _c
}

func (_c *MockSourceFSAdapter_Walk_Call) Return(_a0 error) *MockSourceFSAdapter_Walk_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_Walk_Call) RunAndReturn(run func(model.Path, bool, adapter.FilepathWalkFunc) error) *MockSourceFSAdapter_Walk_Call {
	_c.Call.Return(run)
	return _c
}

// WriteFile provides a mock function with given fields: path, content, perm
func (_m *MockSourceFSAdapter) WriteFile(path model.Path, content []byte, perm fs.FileMode) error {
	ret := _m.Called(path, content, perm)

	if len(ret) == 0 {
		panic("no return value specified for WriteFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(model.Path, []byte, fs.FileMode) error); ok {
		r0 = rf(path, content, perm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSourceFSAdapter_WriteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteFile'
type MockSourceFSAdapter_WriteFile_Call struct {
	*mock.Call
}

// WriteFile is a helper method to define mock.On call
//   - path model.Path
//   - content []byte
//   - perm fs.FileMode
func (_e *MockSourceFSAdapter_Expecter) WriteFile(path interface{}, content interface{}, perm interface{}) *MockSourceFSAdapter_WriteFile_Call {
	return &MockSourceFSAdapter_WriteFile_Call{Call: _e.mock.On("WriteFile", path, content, perm)}
}

func (_c *MockSourceFSAdapter_WriteFile_Call) Run(run func(path model.Path, content []byte, perm fs.FileMode)) *MockSourceFSAdapter_WriteFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(model.Path), args[1].([]byte), args[2].(fs.FileMode))
	})
	return _c
}

func (_c *MockSourceFSAdapter_WriteFile_Call) Return(_a0 error) *MockSourceFSAdapter_WriteFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_WriteFile_Call) RunAndReturn(run func(model.Path, []byte, fs.FileMode) error) *MockSourceFSAdapter_WriteFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSourceFSAdapter creates a new instance of MockSourceFSAdapter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSourceFSAdapter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSourceFSAdapter {
	mock := &MockSourceFSAdapter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
